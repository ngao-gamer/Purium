-- =========================================================================
-- KHAI B√ÅO TH∆Ø VI·ªÜN & SERVICE CHUNG 
-- S·ª¨ D·ª§NG FLUENT/PURIUM GUI (ƒê√É T·ªêI ∆ØU H√ìA)
-- (Script ƒë√£ ƒë∆∞·ª£c fix l·ªói 'missing Title' v√† logic FPS/Ping)
-- =========================================================================
local Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/ngao-gamer/Purium/refs/heads/main/Purium%20Gui"))() 
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local TeleportService = game:GetService("TeleportService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Stats = game:GetService("Stats")
local Lighting = game:GetService("Lighting")
local Debris = game:GetService("Debris")
local LocalPlayer = Players.LocalPlayer
local IYMouse = LocalPlayer:GetMouse()

-- Bi·∫øn to√†n c·ª•c & Flags
local isHoppingForSmallServer = _G.isHoppingForSmallServer or false
local _G = _G or {} 
local notificationSettings = { power = true, roundTime = true, chain = true, artifact = true, airdrop = true, playSound = true }

-- Qu·∫£n l√Ω Thread & Connection
local staminaThread, combatStaminaThread, afkThread, scaleThread, antiGasThread = nil, nil, nil, nil, nil
local jumpConnection, infJumpConnection, espConnection = nil, nil, nil
local staminaLoopActive, combatLoopActive, isScaling = false, false, false
local espElements = {} 
local noclipConnection = nil; local noclipEnabled = false
local BarrierDestroyerEnabled = false; local BarrierDestroyerTask = nil 
local FLYING = false; local iyflyspeed = 1; local flyKeyDown, flyKeyUp 
local isArtifactFarming = false; local artifactFarmingThread = nil 
local isFarming = false; local farmingThread = nil 
local hideEffectsActive = false 
local isFullbrightActive = false; local originalEffectsState = {} 
local infStaminaActive = false; local infGasActive = false; local infResourceThread = nil 

local valuesFolder, aiFolder, artifactsFolder, airDropsFolder = nil, nil, nil, nil

-- KH√îI PH·ª§C BI·∫æN FPS/PING
local updateConnection 
local showFPS = false; local showPing = false 
local fpsLabel, pingLabel
local displayGui
local rainbowHue = 0.0

local chainModel = nil 
local chainEsp = {} 
local chainWarningFlag = false 
local clickTeleportConnection = nil
_G.WRDClickTeleportEnabled = _G.WRDClickTeleportEnabled or false

-- V·ªã tr√≠ Teleport c·ªë ƒë·ªãnh
local TELEPORT_LOCATIONS = {
    ["Spawn / SafeZone"] = CFrame.new(-100, 100, -100),
    ["Outpost (Kh√°c)"] = CFrame.new(0, 100, 500),
    ["Khu V·ª±c Chain"] = CFrame.new(500, 100, 0),
    ["Khu V·ª±c Loot"] = CFrame.new(250, 100, -250),
}


-- =========================================================================
-- LOGIC H·ªñ TR·ª¢ CHUNG & INIT PATHS 
-- =========================================================================
local function getRoot(char) return char:FindFirstChild('HumanoidRootPart') or char:FindFirstChild('Torso') or char:FindFirstChild('UpperTorso') end
local function bringPlr(cframe) 
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then 
        LocalPlayer.Character:PivotTo(cframe * CFrame.new(0, 3, 0)) 
    end 
end 
local function playSound() 
    if notificationSettings.playSound then 
        local sound = Instance.new("Sound"); 
        sound.SoundId = "rbxassetid://100736080025788" 
        sound.Volume = 0.5; 
        sound.Parent = Workspace; 
        sound:Play(); 
        Debris:AddItem(sound, 3)
    end
end
local function findChainBoss()
    if not aiFolder then return nil end
    for _, child in ipairs(aiFolder:GetChildren()) do
        local name = child.Name:lower()
        if name:match("chain") or name:match("thechain") or name:match("boss") then
            return child
        end
    end
    return nil
end
local function findNearestObject(targetFolder, nameMatch)
    local root = getRoot(LocalPlayer.Character)
    if not root or not targetFolder then return nil end
    local smallestDistance = math.huge
    local target = nil

    for _, item in ipairs(targetFolder:GetChildren()) do
        if item.Name:match(nameMatch) and item:IsA("Model") and item:FindFirstChild("PrimaryPart") then 
            local distance = (root.Position - item.PrimaryPart.Position).Magnitude
            if distance < smallestDistance then 
                smallestDistance = distance
                target = item
            end
        end
    end
    return target
end

-- === KHAI B√ÅO BI·∫æN ƒê∆Ø·ªúNG D·∫™N C·ª§ TH·ªÇ V√Ä NOTIFICATION FIX ===
local function setupPowerNotification()
    if not valuesFolder then 
        warn("[Power Notify] valuesFolder not found, retrying in 5s.")
        task.delay(5, setupPowerNotification) 
        return 
    end

    local powerAttribute = "Power" 
    local roundTimeAttribute = "RoundTime"
    local threshold = 30
    local powerNotified = false
    local roundTimeNotified = false
    
    local function checkPower(value)
        if not notificationSettings.power then powerNotified = false; return end
        if type(value) ~= "number" or value <= 0 then return end
        
        local conditionMet = (value <= threshold)
        
        if conditionMet and not powerNotified then
            playSound()
            Fluent:Notify({Title = "C·∫£nh B√°o NƒÉng L∆∞·ª£ng", Content = string.format("NƒÉng l∆∞·ª£ng s·∫Øp h·∫øt! C√≤n %d%%.", math.floor(value)), Duration = 5, Icon = "zap-off"})
            powerNotified = true
        elseif not conditionMet and powerNotified then
            powerNotified = false
        end
    end

    local function checkRoundTime(value)
        if not notificationSettings.roundTime then roundTimeNotified = false; return end
        if type(value) ~= "number" or value <= 0 then return end
        
        local conditionMet = (value <= threshold)
        
        if conditionMet and not roundTimeNotified then
            playSound()
            Fluent:Notify({Title = "V√≤ng Ch∆°i K·∫øt Th√∫c", Content = string.format("V√≤ng ch∆°i s·∫Øp k·∫øt th√∫c! C√≤n %d gi√¢y.", math.floor(value)), Duration = 5, Icon = "clock"})
            roundTimeNotified = true
        elseif not conditionMet and roundTimeNotified then
            roundTimeNotified = false
        end
    end
    
    local initialPower = valuesFolder:GetAttribute(powerAttribute)
    local initialRoundTime = valuesFolder:GetAttribute(roundTimeAttribute)
    if initialPower and type(initialPower) == "number" then checkPower(initialPower) end
    if initialRoundTime and type(initialRoundTime) == "number" then checkRoundTime(initialRoundTime) end

    valuesFolder:GetAttributeChangedSignal(powerAttribute):Connect(function()
        checkPower(valuesFolder:GetAttribute(powerAttribute))
    end)
    valuesFolder:GetAttributeChangedSignal(roundTimeAttribute):Connect(function()
        checkRoundTime(valuesFolder:GetAttribute(roundTimeAttribute))
    end)
end

task.spawn(function() 
    pcall(function()
        local GameStuff = Workspace:WaitForChild("GameStuff", 10)
        local Misc = Workspace:WaitForChild("Misc", 10)
        valuesFolder = GameStuff and GameStuff:WaitForChild("Values", 5)
        aiFolder = Misc and Misc:WaitForChild("AI", 5)
        local Zones = Misc and Misc:WaitForChild("Zones", 5)
        local LootingItems = Zones and Zones:WaitForChild("LootingItems", 5)
        artifactsFolder = LootingItems and LootingItems:WaitForChild("Artifacts", 5)
        airDropsFolder = GameStuff and GameStuff:WaitForChild("GameSections", 5) and GameStuff.GameSections:FindFirstChild("AirDrops")
        
        playSound() 
        setupPowerNotification() 
    end)
end)

-- =========================================================================
-- LOGIC HI·ªÇN TH·ªä FPS/PING (FIXED: C·∫≠p nh·∫≠t showFPS/showPing)
-- =========================================================================

local function createFPSPingDisplay()
    if displayGui then return end

    displayGui = Instance.new("ScreenGui")
    displayGui.Name = "FPS_Ping_Display"
    displayGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    displayGui.DisplayOrder = 100 
    displayGui.IgnoreGuiInset = true 

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 150, 0, 50)
    frame.Position = UDim2.new(1, -160, 0, 10) 
    frame.BackgroundTransparency = 1
    frame.Parent = displayGui

    fpsLabel = Instance.new("TextLabel")
    fpsLabel.Size = UDim2.new(1, 0, 0.5, 0)
    fpsLabel.Position = UDim2.new(0, 0, 0, 0)
    fpsLabel.Text = "FPS: 60"
    fpsLabel.BackgroundTransparency = 1
    fpsLabel.TextColor3 = Color3.fromRGB(255, 255, 255) 
    fpsLabel.TextScaled = true
    fpsLabel.Font = Enum.Font.SourceSansBold
    fpsLabel.TextXAlignment = Enum.TextXAlignment.Right
    fpsLabel.Parent = frame

    pingLabel = Instance.new("TextLabel")
    pingLabel.Size = UDim2.new(1, 0, 0.5, 0)
    pingLabel.Position = UDim2.new(0, 0, 0.5, 0)
    pingLabel.Text = "PING: 0ms"
    pingLabel.BackgroundTransparency = 1
    pingLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    pingLabel.TextScaled = true
    pingLabel.Font = Enum.Font.SourceSansBold
    pingLabel.TextXAlignment = Enum.TextXAlignment.Right
    pingLabel.Parent = frame
    
    displayGui.Parent = CoreGui
end

local function toggleFPSPingDisplay(fpsValue, pingValue)
    showFPS = fpsValue 
    showPing = pingValue 
    
    if showFPS or showPing then
        createFPSPingDisplay()
        if displayGui then displayGui.Enabled = true end 
        
        if not updateConnection then
            updateConnection = RunService.Heartbeat:Connect(function()
                pcall(function()
                    if displayGui and displayGui.Enabled then
                        if showFPS and fpsLabel then
                            local fps = math.floor(1 / task.wait()) 
                            fpsLabel.Text = string.format("FPS: %d", fps)
                            
                            rainbowHue = (rainbowHue + 0.005) % 1 
                            fpsLabel.TextColor3 = Color3.fromHSV(rainbowHue, 1, 1)
                        elseif fpsLabel then
                            fpsLabel.Text = "FPS: Hidden"
                            fpsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
                        end
                        
                        if showPing and pingLabel then
                            local ping = LocalPlayer.GetNetworkStats and LocalPlayer:GetNetworkStats().Ping or 0
                            pingLabel.Text = string.format("PING: %dms", math.floor(ping * 1000))
                        elseif pingLabel then
                            pingLabel.Text = "PING: Hidden"
                        end
                    end
                end)
            end)
        end

        if fpsLabel then fpsLabel.Visible = showFPS end
        if pingLabel then pingLabel.Visible = showPing end
        
    else
        if updateConnection then 
            updateConnection:Disconnect() 
            updateConnection = nil
        end
        if displayGui then displayGui.Enabled = false end
    end
end

-- =========================================================================
-- MOVEMENT/COMBAT LOGIC & INFINITE RESOURCE LOGIC 
-- =========================================================================
local function toggleNoclip(enabled)
    noclipEnabled = enabled
    if enabled then
        noclipConnection = LocalPlayer.Character.Humanoid:GetPropertyChangedSignal("HipHeight"):Connect(function()
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.CanCollide = false
            end
        end)
    else
        if noclipConnection then noclipConnection:Disconnect(); noclipConnection = nil end
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CanCollide = true
        end
    end
end

local function FLY(speed)
    if FLYING then return end
    FLYING = true
    iyflyspeed = speed
    local HRP = getRoot(LocalPlayer.Character)
    if not HRP then return end
    
    local BodyVelocity = Instance.new("BodyVelocity")
    BodyVelocity.MaxForce = Vector3.new(0, 0, 0)
    BodyVelocity.Velocity = Vector3.new(0, 0, 0)
    BodyVelocity.Parent = HRP

    HRP.CFrame = HRP.CFrame + Vector3.new(0, 1, 0)
    
    local function flyUpdate()
        if not FLYING or not HRP or not BodyVelocity then return end
        
        BodyVelocity.MaxForce = Vector3.new(4e9, 4e9, 4e9)
        HRP.Velocity = Vector3.new(0, 0, 0)
        
        local Direction = Vector3.new()
        if flyKeyDown["W"] then Direction = Direction + HRP.CFrame.lookVector end
        if flyKeyDown["S"] then Direction = Direction - HRP.CFrame.lookVector end
        if flyKeyDown["A"] then Direction = Direction - HRP.CFrame.rightVector end
        if flyKeyDown["D"] then Direction = Direction + HRP.CFrame.rightVector end
        if flyKeyDown["Space"] then Direction = Direction + Vector3.new(0, 1, 0) end
        if flyKeyDown["LeftShift"] then Direction = Direction - Vector3.new(0, 1, 0) end

        BodyVelocity.Velocity = Direction.unit * iyflyspeed
    end

    flyKeyDown = {}; flyKeyUp = {}
    
    UserInputService.InputBegan:Connect(function(Input, gameProcessed)
        if gameProcessed or not FLYING then return end
        local Key = Input.KeyCode.Name
        flyKeyDown[Key] = true
    end)
    UserInputService.InputEnded:Connect(function(Input, gameProcessed)
        if gameProcessed or not FLYING then return end
        local Key = Input.KeyCode.Name
        flyKeyDown[Key] = false
    end)

    RunService.Stepped:Connect(flyUpdate)
end

local function NOFLY()
    FLYING = false
    local HRP = getRoot(LocalPlayer.Character)
    if HRP then
        local BodyVelocity = HRP:FindFirstChildOfClass("BodyVelocity")
        if BodyVelocity then BodyVelocity:Destroy() end
    end
end

-- T√ÅCH LOGIC INFINITE STAMINA (CH·ªà X·ª¨ L√ù "Stamina")
local function toggleInfStamina(enabled)
    infStaminaActive = enabled
    if enabled and not infResourceThread then
        infResourceThread = task.spawn(function()
            local maxResource = 100 
            while infStaminaActive or infGasActive do
                pcall(function()
                    if valuesFolder and infStaminaActive then
                        local currentValue = valuesFolder:GetAttribute("Stamina")
                        if currentValue and type(currentValue) == "number" and currentValue < maxResource then
                            valuesFolder:SetAttribute("Stamina", maxResource)
                        end
                    end
                    if valuesFolder and infGasActive then
                        local currentValue = valuesFolder:GetAttribute("Gas")
                        if currentValue and type(currentValue) == "number" and currentValue < maxResource then
                            valuesFolder:SetAttribute("Gas", maxResource)
                        end
                    end
                end)
                task.wait(0.05) 
            end
            infResourceThread = nil
        end)
    elseif not enabled then
        if not infGasActive and infResourceThread then
            task.cancel(infResourceThread)
            infResourceThread = nil
        end
    end
end

-- T√ÅCH LOGIC INFINITE GAS (CH·ªà X·ª¨ L√ù "Gas")
local function toggleInfGas(enabled)
    infGasActive = enabled
    if enabled and not infResourceThread then
        infResourceThread = task.spawn(function()
            local maxResource = 100 
            while infStaminaActive or infGasActive do
                pcall(function()
                    if valuesFolder and infStaminaActive then
                        local currentValue = valuesFolder:GetAttribute("Stamina")
                        if currentValue and type(currentValue) == "number" and currentValue < maxResource then
                            valuesFolder:SetAttribute("Stamina", maxResource)
                        end
                    end
                    if valuesFolder and infGasActive then
                        local currentValue = valuesFolder:GetAttribute("Gas")
                        if currentValue and type(currentValue) == "number" and currentValue < maxResource then
                            valuesFolder:SetAttribute("Gas", maxResource)
                        end
                    end
                end)
                task.wait(0.05) 
            end
            infResourceThread = nil
        end)
    elseif not enabled then
        if not infStaminaActive and infResourceThread then
            task.cancel(infResourceThread)
            infResourceThread = nil
        end
    end
end

-- Click Teleport Logic
local function handleTeleport(input, gameProcessed)
    if not _G.WRDClickTeleportEnabled or gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton2 and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
        local ray = Workspace:Raycast(IYMouse.UnitRay.Origin, IYMouse.UnitRay.Direction * 1000)
        if ray then
            bringPlr(CFrame.new(ray.Position))
            Fluent:Notify({Title = "Click TP", Content = "ƒê√£ d·ªãch chuy·ªÉn t·ªõi ƒëi·ªÉm click.", Duration = 3})
        end
    end
end
local function toggleClickTeleport(enabled)
    _G.WRDClickTeleportEnabled = enabled
    if enabled and not clickTeleportConnection then
        clickTeleportConnection = UserInputService.InputBegan:Connect(handleTeleport)
    elseif not enabled and clickTeleportConnection then
        clickTeleportConnection:Disconnect()
        clickTeleportConnection = nil
    end
end
if _G.WRDClickTeleportEnabled then toggleClickTeleport(true) end


-- =========================================================================
-- ESP LOGIC (PLAYER) - T·ªêI ∆ØU H√ìA LAG 
-- =========================================================================
local espThread = nil
local function cleanupPlayerEspElements(player)
    local elements = espElements[player]
    if elements then
        for _, element in pairs(elements) do
            if element and element.Parent then
                element:Destroy()
            end
        end
        espElements[player] = nil
    end
end

local function updatePlayerEspGui(player)
    local char = player.Character
    if not char then return end
    local elements = espElements[player]
    if not elements or not elements.NameLabel then return end

    local root = getRoot(char)
    if not root then return end
    
    local playerRoot = getRoot(LocalPlayer.Character)
    if not playerRoot then return end

    local distance = math.floor((playerRoot.Position - root.Position).Magnitude)
    local health = char:FindFirstChildOfClass("Humanoid") and math.floor(char:FindFirstChildOfClass("Humanoid").Health) or 0
    local isDead = health <= 0

    elements.NameLabel.Text = string.format("%s\n%dm\n%s Health", player.DisplayName, distance, health)
    
    local highlight = elements.Highlight
    if highlight then
        local color = Color3.fromHSV(math.max(0, health / 100 * (1/3)), 1, 1) 
        highlight.FillColor = color; highlight.OutlineColor = color
    end

    elements.NameLabel.Visible = not isDead
    if highlight then highlight.Enabled = not isDead end
    
    local billGui = elements.BillboardGui
    if billGui then
        local scaleFactor = math.max(1, 100 / distance) * 0.5
        billGui.Size = UDim2.new(0, 100 * scaleFactor, 0, 50 * scaleFactor)
        billGui.Adornee = root 
    end
end

local function startEspLoop()
    if espThread and task.running(espThread) then return end
    espThread = task.spawn(function()
        while true do
            pcall(function()
                for player, elements in pairs(espElements) do
                    updatePlayerEspGui(player)
                end
            end)
            task.wait(0.2) 
        end
    end)
end
local function createPlayerEsp(player)
    local char = player.Character or player.CharacterAdded:Wait()
    local root = getRoot(char)
    if not root or char.Name == LocalPlayer.Name or espElements[player] then return end

    local elements = {}
    
    local highlight = Instance.new("Highlight")
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.FillColor = Color3.fromRGB(255, 255, 255); highlight.FillTransparency = 0.6
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255); highlight.OutlineTransparency = 0
    highlight.Parent = char
    elements.Highlight = highlight

    local billGui = Instance.new("BillboardGui")
    billGui.Name = "PlayerESP_Text"; billGui.AlwaysOnTop = true; billGui.Size = UDim2.new(0, 100, 0, 50)
    billGui.ExtentsOffset = Vector3.new(0, 5, 0)
    billGui.Adornee = root 

    local nameLabel = Instance.new("TextLabel"); nameLabel.Name = "NameLabel"; nameLabel.Size = UDim2.new(1, 0, 1, 0); nameLabel.BackgroundTransparency = 1
    nameLabel.TextColor3 = Color3.new(1, 1, 1); nameLabel.TextStrokeTransparency = 0
    nameLabel.TextScaled = true; nameLabel.Font = Enum.Font.SourceSansBold
    nameLabel.Parent = billGui
    elements.NameLabel = nameLabel
    
    billGui.Parent = CoreGui
    elements.BillboardGui = billGui
    
    player.CharacterAdded:Connect(function(newChar)
        cleanupPlayerEspElements(player)
        createPlayerEsp(player)
    end)

    espElements[player] = elements
end
local function startEspLogic()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then createPlayerEsp(player) end
    end

    Players.PlayerAdded:Connect(createPlayerEsp)
    Players.PlayerRemoving:Connect(cleanupPlayerEspElements)
    
    startEspLoop() 
end
local function stopEspLogic()
    if espConnection then espConnection:Disconnect(); espConnection = nil end
    if espThread then task.cancel(espThread); espThread = nil end 
    for player, elements in pairs(espElements) do cleanupPlayerEspElements(player) end
    espElements = {}
end

-- =========================================================================
-- ESP LOGIC (CHAIN BOSS) & AUTO-TRACKING 
-- =========================================================================
local chainEspThread = nil
local function cleanupChainEsp()
    for _, element in pairs(chainEsp) do if element and element.Parent then element:Destroy() end end
    chainEsp = {}
    chainModel = nil
end

local function updateChainEsp(model)
    if not model or not LocalPlayer.Character or not getRoot(LocalPlayer.Character) then return end
    local root = getRoot(model)
    local humanoid = model:FindFirstChildOfClass("Humanoid")
    local playerRoot = getRoot(LocalPlayer.Character)
    if not root or not humanoid or not playerRoot then return end

    if not chainEsp.Highlight then
        chainEsp.Highlight = Instance.new("Highlight")
        chainEsp.Highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        chainEsp.Highlight.FillColor = Color3.fromRGB(255, 100, 0); chainEsp.Highlight.FillTransparency = 0.5 
        chainEsp.Highlight.OutlineColor = Color3.fromRGB(255, 100, 0); chainEsp.Highlight.OutlineTransparency = 0 
        chainEsp.Highlight.Parent = model
        
        chainEsp.BillboardGui = Instance.new("BillboardGui")
        chainEsp.BillboardGui.Name = "ChainESP_Text"; chainEsp.BillboardGui.AlwaysOnTop = true; chainEsp.BillboardGui.Size = UDim2.new(0, 200, 0, 80)
        chainEsp.BillboardGui.ExtentsOffset = Vector3.new(0, 5, 0)
        chainEsp.BillboardGui.Adornee = root
        chainEsp.BillboardGui.Parent = CoreGui
        
        chainEsp.NameLabel = Instance.new("TextLabel"); chainEsp.NameLabel.Name = "NameLabel"; chainEsp.NameLabel.Size = UDim2.new(1, 0, 1, 0); chainEsp.NameLabel.BackgroundTransparency = 1
        chainEsp.NameLabel.TextColor3 = Color3.fromRGB(255, 100, 0); chainEsp.NameLabel.TextStrokeTransparency = 0
        chainEsp.NameLabel.TextScaled = true; chainEsp.NameLabel.Font = Enum.Font.SourceSansBold
        chainEsp.NameLabel.TextWrapped = true
        chainEsp.NameLabel.Parent = chainEsp.BillboardGui
    end
    
    local distance = math.floor((playerRoot.Position - root.Position).Magnitude)
    local health = math.floor(humanoid.Health)
    local maxHealth = math.floor(humanoid.MaxHealth)
    
    chainEsp.NameLabel.Text = string.format("CHAIN BOSS\n%d/%d HP\n%dm", health, maxHealth, distance)
    
    local scaleFactor = math.max(1, 200 / distance) * 0.5
    chainEsp.BillboardGui.Size = UDim2.new(0, 150 * scaleFactor, 0, 75 * scaleFactor)
    
    if distance >= 150 and distance <= 180 and not chainWarningFlag then
        if notificationSettings.chain then 
             playSound()
             Fluent:Notify({Title = "CHAIN WARNING", Content = string.format("Chain Boss ƒëang ·ªü g·∫ßn! (%dm)", distance), Duration = 5, Icon = "alert-triangle"}) 
             chainWarningFlag = true 
             task.spawn(function()
                 task.wait(15) 
                 chainWarningFlag = false
             end)
        end
    end
end

local function startChainEspLogic()
    if chainEspThread then return end
    
    chainEspThread = task.spawn(function()
        while true do
            pcall(function()
                local newChainModel = findChainBoss()
                
                if newChainModel and newChainModel ~= chainModel then
                    cleanupChainEsp() 
                    chainModel = newChainModel
                end
                
                if chainModel then
                    if chainModel.Parent == aiFolder then 
                         updateChainEsp(chainModel)
                    else
                        cleanupChainEsp()
                    end
                end
            end)
            task.wait(0.2) 
        end
    end)
end

local function stopChainEspLogic()
    if chainEspThread then task.cancel(chainEspThread); chainEspThread = nil end
    cleanupChainEsp()
end

-- =========================================================================
-- AFK BYPASS LOGIC 
-- =========================================================================
local afkThread = nil
local isAfkActive = false

local function toggleAntiAFK(enabled)
    isAfkActive = enabled
    if enabled and not afkThread then
        afkThread = task.spawn(function()
            while isAfkActive do
                pcall(function()
                    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
                        LocalPlayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                        local HRP = getRoot(LocalPlayer.Character)
                        if HRP then
                            HRP.CFrame = HRP.CFrame * CFrame.Angles(0, math.rad(0.001), 0)
                        end
                    end
                end)
                task.wait(20) 
            end
        end)
    elseif not enabled and afkThread then
        task.cancel(afkThread)
        afkThread = nil
    end
end

-- =========================================================================
-- KH·ªûI T·∫†O UI & TABS
-- =========================================================================
local Window = Fluent:CreateWindow({
    Title = "Purium Hub [Premium] | Universal |",
    SubTitle = "Script Finalized (v7.9) - Confirmed UI Fix", 
    Search = true,
    Icon = "rbxassetid://121302760641013",
    TabWidth = 140,
    Size = UDim2.fromOffset(650, 450), 
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.RightAlt,
    UserInfo = true, UserInfoTop = false, UserInfoTitle = LocalPlayer.DisplayName,
    UserInfoSubtitle = "Premuim User", UserInfoSubtitleColor = Color3.fromRGB(71, 123, 255)
})

local Tabs = {
    Main0=Window:AddTab({ Title="Annoucenment", Icon = "info" }),
    Main1=Window:AddTab({ Title="Movement / Combat", Icon = "swords" }),
    Teleport=Window:AddTab({ Title="Teleport", Icon = "globe" }), 
    Main2=Window:AddTab({ Title="Esp / Visuals", Icon = "user-plus"}),
    AutoFarmTab=Window:AddTab({ Title="AutoFarm", Icon = "feather"}),
    Notifications=Window:AddTab({ Title="Notifications", Icon = "bell-ring"}),
    Main4=Window:AddTab({ Title="Utility / Server", Icon = "cog"}), 
    Main5=Window:AddTab({ Title="Environment", Icon = "sun"}),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("Purium HUB")
SaveManager:SetFolder("Purium HUB/universal")
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)
Window:SelectTab(1)
Fluent:Notify({ 
Title = "Purium HUB",
Content = "Script Finalized (v7.9) - Confirmed 'Title' parameter is crucial for Toggles.", 
Duration = 4 })
SaveManager:LoadAutoloadConfig()


-- =========================================================================
-- N·ªòI DUNG TAB ANNOUNCEMENT (Main0) 
-- =========================================================================
Tabs.Main0:AddSection("‚Ü≥ Info / Credits")
Tabs.Main0:AddParagraph({ 
    Title = "Finalized Universal Script (v7.9)", 
    Description = "ƒê√£ x√°c nh·∫≠n v√† s·ª≠a l·ªói thi·∫øu `Title` trong tab Notifications. L·ªói FPS/Ping `GetElement` ƒë√£ ƒë∆∞·ª£c s·ª≠a ho√†n to√†n ·ªü phi√™n b·∫£n tr∆∞·ªõc. Script ƒë√£ ƒë∆∞·ª£c t·ªëi ∆∞u h√≥a cho Fluent GUI.",
})
Tabs.Main0:AddParagraph({ 
    Title = "üõ†Ô∏è Developer: hlck49", 
    Description = "Thi·∫øt k·∫ø v√† ph√°t tri·ªÉn giao di·ªán ng∆∞·ªùi d√πng (UI Library: Fluent/Purium).",
})
Tabs.Main0:AddParagraph({ 
    Title = "‚öôÔ∏è Code Logic: @unknow", 
    Description = "H·ªó tr·ª£ ph√°t tri·ªÉn v√† logic code ch√≠nh.",
})


-- =========================================================================
-- N·ªòI DUNG TAB MOVEMENT / COMBAT (Main1)
-- =========================================================================
Tabs.Main1:AddSection("‚Ü≥ Infinite Hacks (Separated)")
Tabs.Main1:AddToggle("InfiniteStaminaToggle", {
    Title = "**Infinite Stamina**",
    Description = "C·ªë g·∫Øng duy tr√¨ Stamina ·ªü m·ª©c t·ªëi ƒëa.",
    Default = false,
}):OnChanged(toggleInfStamina) 

Tabs.Main1:AddToggle("InfiniteGasToggle", {
    Title = "**Infinite Gas**",
    Description = "C·ªë g·∫Øng duy tr√¨ Gas ·ªü m·ª©c t·ªëi ƒëa.",
    Default = false,
}):OnChanged(toggleInfGas) 

Tabs.Main1:AddSection("‚Ü≥ Movement Hacks")
Tabs.Main1:AddToggle("InfiniteJumpToggle", {
    Title = "Infinite Jump",
    Description = "Nh·∫£y v√¥ h·∫°n.",
    Default = false,
}):OnChanged(function(Value)
    if Value == true then
        infJumpConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Space and not gameProcessed then
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
                    LocalPlayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end
        end)
    elseif infJumpConnection then
        infJumpConnection:Disconnect()
        infJumpConnection = nil
    end
end)

Tabs.Main1:AddToggle("FlyToggle", {
    Title = "Fly (V-Key)",
    Description = "B·∫≠t ch·∫ø ƒë·ªô bay (Nh·∫•n V ƒë·ªÉ bay/t·∫Øt).",
    Default = false,
}):OnChanged(function(Value)
    if Value == true then FLY(50) else NOFLY() end
end)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.V then
        local toggle = Tabs.Main1:GetElement("FlyToggle")
        if toggle then
            toggle:SetValue(not toggle.Value)
        end
    end
end)

Tabs.Main1:AddSection("‚Ü≥ Noclip / CanCollide")
Tabs.Main1:AddToggle("NoClipToggle", {
    Title = "NoClip (Xuy√™n t∆∞·ªùng)",
    Description = "Cho ph√©p ƒëi xuy√™n qua c√°c v·∫≠t th·ªÉ.",
    Default = false,
}):OnChanged(function(Value)
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
        toggleNoclip(Value)
    end
end)


-- =========================================================================
-- N·ªòI DUNG TAB TELEPORT 
-- =========================================================================
Tabs.Teleport:AddSection("‚Ü≥ Click Teleport")
Tabs.Teleport:AddToggle("ClickTeleportToggle", { 
    Title = "Click Teleport (Ctrl + Click)", 
    Description = "Nh·∫•n gi·ªØ Ctrl + Click chu·ªôt ph·∫£i ƒë·ªÉ d·ªãch chuy·ªÉn.", 
    Default = _G.WRDClickTeleportEnabled, 
    Flag = "ClickTeleportToggle", 
    Callback = toggleClickTeleport,
})

Tabs.Teleport:AddSection("‚Ü≥ Teleport To Hardcoded Locations")
for name, cframe in pairs(TELEPORT_LOCATIONS) do
    Tabs.Teleport:AddButton({
        Title = "TP: " .. name,
        Description = "D·ªãch chuy·ªÉn t·ªõi: " .. name,
        Callback = function()
            bringPlr(cframe)
            Fluent:Notify({Title = "Teleported", Content = "ƒê√£ d·ªãch chuy·ªÉn t·ªõi: " .. name, Duration = 3})
        end
    })
end
Tabs.Teleport:AddButton({
    Title = "TP: Chain Boss (Dynamic)",
    Description = "D·ªãch chuy·ªÉn t·ªõi Chain Boss (n·∫øu ƒëang ·ªü tr√™n b·∫£n ƒë·ªì).",
    Callback = function()
        pcall(function()
            local chain = findChainBoss()
            if chain and chain:FindFirstChild("HumanoidRootPart") then
                bringPlr(chain:GetPivot())
                Fluent:Notify({Title = "Teleported", Content = "ƒê√£ d·ªãch chuy·ªÉn t·ªõi Chain Boss.", Duration = 3})
            else
                Fluent:Notify({Title = "Error", Content = "Kh√¥ng t√¨m th·∫•y Chain Boss tr√™n b·∫£n ƒë·ªì.", Duration = 3})
            end
        end)
    end
})


-- =========================================================================
-- N·ªòI DUNG TAB ESP / VISUALS (Main2)
-- =========================================================================
Tabs.Main2:AddSection("‚Ü≥ Player & AI ESP")
Tabs.Main2:AddToggle("PlayerChams_Toggle_FIXED_V5", { 
    Title = "**Esp Players (T·ªëi ∆∞u Lag FIX)**", 
    Description = "Hi·ªÉn th·ªã t√™n/kho·∫£ng c√°ch ch√≠nh x√°c v√† Box/Outline ESP.", 
    Default = false, 
}):OnChanged(function(Value) if Value == true then startEspLogic() else stopEspLogic() end end)

Tabs.Main2:AddToggle("ChainBossEspToggle_V1", { 
    Title = "**Chain Boss ESP (Auto-Tracking FIX)**", 
    Description = "Highlight v√† hi·ªÉn th·ªã th√¥ng tin Chi ti·∫øt Chain Boss (T·ª± ƒë·ªông b·∫≠t l·∫°i khi Boss h·ªìi sinh).", 
    Default = false, 
}):OnChanged(function(Value) if Value then startChainEspLogic() else stopChainEspLogic() end end)

Tabs.Main2:AddSection("‚Ü≥ Information Display")
Tabs.Main2:AddToggle("DisplayFPSToggle", {
    Title = "**Display FPS (Rainbow)**",
    Description = "Hi·ªÉn th·ªã s·ªë khung h√¨nh tr√™n gi√¢y (Frames Per Second) v·ªõi m√†u c·∫ßu v·ªìng.",
    Default = false,
}):OnChanged(function(Value) 
    toggleFPSPingDisplay(Value, showPing) 
end)

Tabs.Main2:AddToggle("DisplayPingToggle", {
    Title = "Display Ping (Latency)",
    Description = "Hi·ªÉn th·ªã ƒë·ªô tr·ªÖ m·∫°ng (Ping) t√≠nh b·∫±ng ms.",
    Default = false,
}):OnChanged(function(Value) 
    toggleFPSPingDisplay(showFPS, Value)
end)

-- =========================================================================
-- N·ªòI DUNG TAB AUTOFARM (AutoFarmTab)
-- =========================================================================
Tabs.AutoFarmTab:AddSection("‚Ü≥ Artifact Farming (Experimental)")
Tabs.AutoFarmTab:AddToggle("ArtifactFarmToggle", {
    Title = "Auto Artifact Farm",
    Description = "T·ª± ƒë·ªông d·ªãch chuy·ªÉn v√† nh·∫∑t Artifact (c·∫ßn b·∫≠t Click TP).",
    Default = false,
}):OnChanged(function(Value)
    isArtifactFarming = Value
    if Value and not artifactFarmingThread then
        artifactFarmingThread = task.spawn(function()
            while isArtifactFarming do
                pcall(function()
                    local target = findNearestObject(artifactsFolder, "Artifact")
                    if target and target:FindFirstChild("PrimaryPart") then
                        bringPlr(target:GetPivot())
                        task.wait(1) 
                    end
                end)
                task.wait(5) 
            end
            artifactFarmingThread = nil
        end)
    elseif not Value and artifactFarmingThread then
        task.cancel(artifactFarmingThread)
        artifactFarmingThread = nil
    end
end)


-- =========================================================================
-- N·ªòI DUNG TAB NOTIFICATIONS (ƒê√É FIX L·ªñI THI·∫æU TITLE)
-- =========================================================================
Tabs.Notifications:AddSection("‚Ü≥ Notification Toggles (FIXED)")
Tabs.Notifications:AddToggle("NotifyPowerToggle_v4_EN", { 
    Title = "Low Power (30%)", -- FIX: ƒê√£ th√™m Title
    Name = "Low Power (30%)", 
    CurrentValue = notificationSettings.power 
}):OnChanged(function(Value) notificationSettings.power = Value end)

Tabs.Notifications:AddToggle("NotifyRoundTimeToggle_v4_EN", { 
    Title = "End of Round (30s)", -- FIX: ƒê√£ th√™m Title
    Name = "End of Round (30s)", 
    CurrentValue = notificationSettings.roundTime 
}):OnChanged(function(Value) notificationSettings.roundTime = Value end)

Tabs.Notifications:AddToggle("NotifyChainToggle_v4_EN", { 
    Title = "CHAIN Spawn / Defeat", -- FIX: ƒê√£ th√™m Title
    Name = "CHAIN Spawn / Defeat", 
    CurrentValue = notificationSettings.chain 
}):OnChanged(function(Value) notificationSettings.chain = Value end)

Tabs.Notifications:AddToggle("NotifyArtifactToggle_v4_EN", { 
    Title = "Artifact Spawn", -- FIX: ƒê√£ th√™m Title
    Name = "Artifact Spawn", 
    CurrentValue = notificationSettings.artifact 
}):OnChanged(function(Value) notificationSettings.artifact = Value end)

Tabs.Notifications:AddToggle("NotifyAirdropToggle_v1_EN", { 
    Title = "Airdrop Spawn", -- FIX: ƒê√£ th√™m Title
    Name = "Airdrop Spawn", 
    CurrentValue = notificationSettings.airdrop 
}):OnChanged(function(Value) notificationSettings.airdrop = Value end)

Tabs.Notifications:AddSection("‚Ü≥ Options")
Tabs.Notifications:AddToggle("PlaySoundToggle", { 
    Title = "Play Sound on Notification", -- FIX: ƒê√£ th√™m Title
    Name = "Play Sound on Notification", 
    CurrentValue = notificationSettings.playSound 
}):OnChanged(function(Value) notificationSettings.playSound = Value end)


-- =========================================================================
-- N·ªòI DUNG TAB UTILITY / SERVER (Main4)
-- =========================================================================
Tabs.Main4:AddSection("‚Ü≥ Utility")
Tabs.Main4:AddToggle("AntiAFKToggle", {
    Title = "Anti-AFK (AFK Bypass)",
    Description = "NgƒÉn ch·∫∑n vi·ªác b·ªã kick v√¨ kh√¥ng ho·∫°t ƒë·ªông (Anti-Idle).",
    Default = false,
}):OnChanged(toggleAntiAFK)

Tabs.Main4:AddSection("‚Ü≥ Server Hopping")
Tabs.Main4:AddToggle("SmallServerHopToggle", {
    Title = "Look for a small server (<5 players)",
    Description = "T√¨m ki·∫øm v√† d·ªãch chuy·ªÉn ƒë·∫øn m√°y ch·ªß c√≥ √≠t h∆°n 5 ng∆∞·ªùi ch∆°i.",
    Default = isHoppingForSmallServer,
    Flag = "SmallServerHopToggle",
    Callback = function(Value)
        _G.isHoppingForSmallServer = Value
        if _G.isHoppingForSmallServer then
             Fluent:Notify({Title = "Search Engine Active", Content = "ƒêang t√¨m m√°y ch·ªß c√≥ √≠t h∆°n 5 ng∆∞·ªùi ch∆°i...", Duration = 6})
             
             if #Players:GetPlayers() < 5 then
                 Fluent:Notify({Title = "Found!", Content = "M√°y ch·ªß n√†y ƒë√£ c√≥ √≠t ng∆∞·ªùi ch∆°i. D·ª´ng t√¨m ki·∫øm.", Duration = 5})
                 _G.isHoppingForSmallServer = false
                 local toggle = Tabs.Main4:GetElement("SmallServerHopToggle")
                 if toggle then toggle:SetValue(false) end
                 return
             end
             
             TeleportService:Teleport(game.PlaceId, LocalPlayer)
        else
            Fluent:Notify({Title = "Search Engine Stopped", Content = "ƒê√£ d·ª´ng t√¨m ki·∫øm m√°y ch·ªß nh·ªè.", Duration = 5})
        end
    end,
})

-- =========================================================================
-- N·ªòI DUNG TAB ENVIRONMENT (Main5)
-- =========================================================================
Tabs.Main5:AddSection("‚Ü≥ Visual & Effects")
Tabs.Main5:AddToggle("FullBrightToggle", {
    Title = "Full Bright (S√°ng to√†n c·∫£nh)",
    Description = "TƒÉng ƒë·ªô s√°ng t·ªëi ƒëa, lo·∫°i b·ªè b√≥ng t·ªëi (Bao g·ªìm NoFog).",
    Default = false,
}):OnChanged(function(Value)
    isFullbrightActive = Value
    if Value then
        originalEffectsState = {}
        for _, effect in ipairs(Lighting:GetChildren()) do
            if effect:IsA("ColorCorrectionEffect") or effect:IsA("BlurEffect") or effect:IsA("BloomEffect") or effect:IsA("AmbientSound") then
                originalEffectsState[effect.Name] = effect.Enabled
                effect.Enabled = false
            end
        end
        Lighting.Ambient = Color3.fromRGB(255, 255, 255)
        Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
        Lighting.Brightness = 3
    else
        Lighting.Ambient = Color3.fromRGB(120, 120, 120) 
        Lighting.OutdoorAmbient = Color3.fromRGB(120, 120, 120) 
        Lighting.Brightness = 1 
        for _, effect in ipairs(Lighting:GetChildren()) do
            if originalEffectsState[effect.Name] ~= nil then
                effect.Enabled = originalEffectsState[effect.Name]
            end
        end
        originalEffectsState = {}
    end
end)


-- =========================================================================
-- N·ªòI DUNG TAB SETTINGS (Settings)
-- =========================================================================
Tabs.Settings:AddSection("‚Ü≥ Config")

Tabs.Settings:AddButton({
    Title = "Destroy UI", 
    Description = "ƒê√≥ng v√† x√≥a to√†n b·ªô giao di·ªán Script.",
    Callback = function() 
        Window:Destroy()
        if CoreGui:FindFirstChild("MinimizeUI") then CoreGui.MinimizeUI:Destroy() end
        if CoreGui:FindFirstChild("FPS_Ping_Display") then CoreGui.FPS_Ping_Display:Destroy() end
        if updateConnection then updateConnection:Disconnect(); updateConnection = nil end
        
        stopEspLogic() 
        stopChainEspLogic()
        NOFLY()
        toggleNoclip(false)
        toggleClickTeleport(false)
        toggleInfStamina(false) 
        toggleInfGas(false)
        toggleAntiAFK(false) 
    end,
})

-- =========================================================================
-- KH·ªûI T·∫†O SAU KHI T·∫¢I CONFIG 
-- =========================================================================
task.spawn(function()
    task.wait(2) 
    pcall(function()
        local savedFPS = SaveManager:GetConfig("DisplayFPSToggle", false) 
        local savedPing = SaveManager:GetConfig("DisplayPingToggle", false)
        local savedStamina = SaveManager:GetConfig("InfiniteStaminaToggle", false)
        local savedGas = SaveManager:GetConfig("InfiniteGasToggle", false)

        -- K√≠ch ho·∫°t logic hi·ªÉn th·ªã FPS/Ping v·ªõi gi√° tr·ªã ƒë√£ l∆∞u
        toggleFPSPingDisplay(savedFPS, savedPing) 

        -- K√≠ch ho·∫°t logic Infinite Resource v·ªõi gi√° tr·ªã ƒë√£ l∆∞u
        if savedStamina then toggleInfStamina(true) end
        if savedGas then toggleInfGas(true) end
    end)
end)

local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")

local ExistingUI = CoreGui:FindFirstChild("PuriumHubMinimizeUI")
if ExistingUI then
    ExistingUI:Destroy()
end

local DragUI = Instance.new("ScreenGui")
DragUI.Name = "PuriumHubMinimizeUI"
DragUI.ResetOnSpawn = false
DragUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
DragUI.Parent = CoreGui


local Button = Instance.new("ImageButton")
Button.Parent = DragUI
Button.Size = UDim2.new(0, 50, 0, 50)
Button.Position = UDim2.new(0, 10, 1, -85)
Button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Button.BackgroundTransparency = 0.3
Button.BorderSizePixel = 0
Button.ClipsDescendants = true
Button.Image = "rbxassetid://109647470925993" -- Thay icon n·∫øu mu·ªën
Button.ScaleType = Enum.ScaleType.Fit
Button.Active = true
Button.ZIndex = 1000


local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(1, 0)
UICorner.Parent = Button


local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

local function ToggleUI()
    if Window.Minimized then
        Window:Minimize(false) 
    else
        Window:Minimize(true) 
    end
end

local isDragging = false
local dragThreshold = 10

Button.MouseButton1Click:Connect(function()
    if isDragging then return end

    TweenService:Create(Button, tweenInfo, {
        BackgroundTransparency = 0.5,
        Size = UDim2.new(0, 45, 0, 45),
        Rotation = 5
    }):Play()
    task.wait(0.1)
    TweenService:Create(Button, tweenInfo, {
        BackgroundTransparency = 0.3,
        Size = UDim2.new(0, 50, 0, 50),
        Rotation = 0
    }):Play()

    ToggleUI()
end)

Button.MouseEnter:Connect(function()
    TweenService:Create(Button, tweenInfo, {Size = UDim2.new(0, 55, 0, 55)}):Play()
end)

Button.MouseLeave:Connect(function()
    TweenService:Create(Button, tweenInfo, {Size = UDim2.new(0, 50, 0, 50)}):Play()
end)


local dragging, dragStart, startPos

local function StartDrag(input)
    isDragging = false
    dragging = true
    dragStart = input.Position
    startPos = Button.Position

    input.Changed:Connect(function()
        if input.UserInputState == Enum.UserInputState.End then
            dragging = false
        end
    end)
end

local function OnDrag(input)
    if dragging then
        local delta = (input.Position - dragStart).Magnitude
        if delta > dragThreshold then
            isDragging = true
        end
        Button.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + (input.Position.X - dragStart.X),
            startPos.Y.Scale,
            startPos.Y.Offset + (input.Position.Y - dragStart.Y)
        )
    end
end

Button.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        StartDrag(input)
    end
end)

Button.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        OnDrag(input)
    end
end)  
